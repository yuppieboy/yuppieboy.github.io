<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用python编写简单的登陆API]]></title>
      <url>%2F2016%2F11%2F14%2F%E4%BD%BF%E7%94%A8python%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E9%99%86API%2F</url>
      <content type="text"><![CDATA[框架Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。 思路利用Flask,通过和数据库校验用户名密码来判断是否可以登陆成功。 实现#!/usr/bin/python # -*- coding: utf-8 -*- from flask import Flask, request, render_template, Response import MySQLdb import json app = Flask(__name__) @app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def login(): if request.method == &apos;POST&apos;: if valid_login(request.form[&apos;username&apos;], request.form[&apos;password&apos;]): return json.dumps({&apos;status&apos;: 1, &apos;data&apos;: &apos;login success&apos;}) else: error = &apos;Invalid username/password&apos; return error else: return &apos;Not Support Get&apos; def valid_login(username,password): conn = MySQLdb.connect( host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, # passwd=&apos;&apos;, db=&apos;Test&apos; ) cur = conn.cursor() resp = [] try: sql = &quot;select * from user where name = &apos;%s&apos; and password = &apos;%s&apos;&quot; % (username, password) cur.execute(sql) resp = cur.fetchall() conn.commit() except Exception as e: print e conn.rollback() cur.close() conn.close() return len(resp) if __name__ == &apos;__main__&apos;: app.run(host=&quot;127.0.0.1&quot;, port=8080, debug=True) 部署pycharm运行xxx.py即可 * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger pin code: 273-703-379 Mac默认开启apache服务占用了80端口，所以这边暂时使用8080作为测试端口在本地测试。 小结用Python写Restful风格的webAPI其实蛮方便，也容易部署，小项目容易上手，本文所写API只为好玩，真实项目要考虑更多的东西，比如加密等等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python图片转字符串画]]></title>
      <url>%2F2016%2F11%2F11%2Fpython%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%BB%2F</url>
      <content type="text"><![CDATA[原理把图片各像素根据灰度值转成不同的自定义字符串然后显示出来。 依赖库使用第三方库pillow: sudo -H pip --default-timeout=100 install pillow 实现#!/usr/bin/python # -*- coding: utf-8 -*- from PIL import Image ascii_char = list(&quot;##$&amp; &quot;) count = len(ascii_char) def toText(image_file): string = &apos;&apos; for h in range(0, image_file.size[1]): # h for w in range(0, image_file.size[0]): # w r, g, b = image_file.getpixel((w, h)) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = 255.0 / len(ascii_char) string = string + ascii_char[int(gray / unit)] string = string + &apos;\n&apos; return string image_file = Image.open(&quot;lks.jpg&quot;) image_file = image_file.resize((int(image_file.size[0]*0.2), int(image_file.size[1] * 0.1))) # 调整图片大小 print u&apos;Info:&apos;, image_file.size[0], &apos; &apos;, image_file.size[1], &apos; &apos;, count with open(&apos;lks.txt&apos;,&apos;w&apos;) as f: f.write(toText(image_file)) 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL注入原理浅析]]></title>
      <url>%2F2016%2F11%2F10%2FSQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[原理SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 攻击API在编写过程中没有过滤用户输入的非法字符串，很容易造成sql注入，以mysql-python为例： conn = MySQLdb.connect( host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, # passwd=&apos;&apos;, db=&apos;Test&apos; ) cur = conn.cursor() try: name = &quot;1 or 1 = 1&quot; password = &quot;1 or 1 = 1&quot; sql = &apos;select * from user where name = %s and password = %s&apos;%(name,password) cur.execute(sql) print cur.fetchall() conn.commit() except Exception as e: print e conn.rollback() cur.close() conn.close() result： ((&apos;Tom&apos;, &apos;0000&apos;, &apos;\xe5\xa5\xb3&apos;), (&apos;Alen&apos;, &apos;7875&apos;, &apos;\xe7\x94\xb7&apos;), (&apos;Jack&apos;, &apos;7455&apos;, &apos;\xe7\x94\xb7&apos;)) 很明显使用简单的&quot;1 or 1 = 1&quot;就欺骗了数据库获取了所以user表内容。 防护归纳一下，主要有以下几点： 1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 小结SQL注入的手法相当灵活，在注入的时候会碰到很多意外的情况。能不能根据具体情况进行分析，构造巧妙的SQL语句，从而成功获取想要的数据，是高手与“菜鸟”的根本区别。😊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转载】Ruby China的RubyGems镜像上线]]></title>
      <url>%2F2016%2F11%2F01%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Ruby-China%E7%9A%84RubyGems%E9%95%9C%E5%83%8F%E4%B8%8A%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[公告huacnlee for Ruby China · 发布于 2016年3月09日 · 最后由 huopo125 回复于 2016年5月12日 几年前，由我起头，我们搭建了 ruby.taobao.org 为国内开发者解决 Gem 安装的问题，现在应该国内绝大多数，甚至所有（国内服务器，国内网络）的 Ruby 开发者企业，应该都在用它。 但最近越来越发现之前 ruby.taobao.org 很难同步了，原因有很多，之前的实现方式过于复杂，服务器在国内，同步困难，阿里的网络安全要求维护服务器得是公司员工…. 各种限制导致我们在维护的时候困难重重，尤其是当 @fsword @qhwa 离职以后，根本无法再继续维护了。 为了有一个可持续发展未来，我们考虑由 Ruby China 来负责这个事情，这样可以像现在 Ruby China 社区，RubyConf China 一样，由社区的很多参与者来共同维护。 这件事情我们已经考虑了一年了，之前一直没有找到一个好的方式来解决，以及一些其他因素，比如资金的问题。 这周，我们终于找到了解决方案，也找到了赞助商：腾讯云 整个 gems.ruby-china.org 的架构: 2016-05-18 Updated: Gems 存储放到了 UpYun 上面，通过 UpYun 的 CDN 来解决，同时配合 UpYun 的镜像存储功能，减少回源到国外的次数。 过程: https://ruby-china.org/topics/29978 新的方案的特点 实时的，不再有同步耗时的问题； 全球 400+ CDN 节点（据腾讯官方所说 ~~）为 Gem 下载加速； 更加简单有效的架构，稳定性更高； 背后有两台国外服务器，确保稳定性，确保 CDN 汇源能获取到数据； 原文链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FFmpeg的安装与使用]]></title>
      <url>%2F2016%2F10%2F31%2FFFmpeg%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[简介FFmpeg是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库。“FFmpeg”这个单词中的“FF”指的是“Fast Forward”。有些新手写信给“FFmpeg”的项目负责人，询问FF是不是代表“Fast Free”或者“Fast Fourier”等意思，“FFmpeg”的项目负责人回信说：“Just for the record, the original meaning of “FF” in FFmpeg is “Fast Forward”…”这个项目最初是由Fabrice Bellard发起的，而现在是由Michael Niedermayer在进行维护。许多FFmpeg的开发者同时也是MPlayer项目的成员，FFmpeg在MPlayer项目中是被设计为服务器版本进行开发。2011年3月13日，FFmpeg部分开发人士决定另组Libav，同时制定了一套关于项目继续发展和维护的规则。(From FFmpeg Wiki) 安装brew install ffmpeg 由于license的原因，libvo-aacenc被默认安装，如果想要安装libfaac或者libfdk-aac可以通过以下命令： brew reinstall ffmpeg --with-faac brew reinstall ffmpeg --with-fdk-aac 项目组成libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能 libavcodec：用于各种类型声音/图像编解码 libavutil：包含一些公共的工具函数 libswscale：用于视频场景比例缩放、色彩映射转换 libpostproc：用于后期效果处理 ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等 ffsever：一个 HTTP 多媒体即时广播串流服务器 ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示 命令集ffmpeg 命令集举例 1.获取视频的信息 ffmpeg -i video.avi 2.将图片序列合成视频 ffmpeg -f image2 -i image%d.jpg video.mpg 上面的命令会把当前目录下的图片（名字如：image1.jpg. image2.jpg. 等…）合并成video.mpg 3.将视频分解成图片序列 ffmpeg -i video.mpg image%d.jpg 上面的命令会生成image1.jpg. image2.jpg. …支持的图片格式有：PGM. PPM. PAM. PGMYUV. JPEG. GIF. PNG. TIFF. SGI 4.为视频重新编码以适合在iPod/iPhone上播放 ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4 说明： 源视频：source_video.avi 音频编码：aac 音频位率：128kb/s 视频编码：mpeg4 视频位率：1200kb/s 视频尺寸：320 X 180 生成的视频：final_video.mp4 5.为视频重新编码以适合在PSP上播放 ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.mp4 说明： 源视频：source_video.avi 音频编码：aac 音频位率：32kb/s 视频编码：xvid 视频位率：1200kb/s 视频尺寸：320 X 180 生成的视频：final_video.mp4 6.从视频抽出声音.并存为Mp3 ffmpeg -i source_video.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 sound.mp3 说明： 源视频：source_video.avi 音频位率：192kb/s 输出格式：mp3 生成的声音：sound.mp3 7.将wav文件转成Mp3 ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3 8.将.avi视频转成.mpg ffmpeg -i video_origine.avi video_finale.mpg 9.将.mpg转成.avi ffmpeg -i video_origine.mpg video_finale.avi 10.将.avi转成gif动画（未压缩） ffmpeg -i video_origine.avi gif_anime.gif 11.合成视频和音频 ffmpeg -i son.wav -i video_origine.avi video_finale.mpg 12.将.avi转成.flv ffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv 13.将.avi转成dv ffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv 或者： ffmpeg -i video_origine.avi -target pal-dv video_finale.dv 14.将.avi压缩成divx ffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi 15.将Ogg Theora压缩成Mpeg dvd ffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg 16.将.avi压缩成SVCD mpeg2NTSC格式： ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpg PAL格式： ffmpeg -i video_origine.avi -target pal-svcd video_finale.mpg 17.将.avi压缩成VCD mpeg2NTSC格式： ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpg PAL格式： ffmpeg -i video_origine.avi -target pal-vcd video_finale.mpg 18.多通道编码 ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2 19.从flv提取mp3 ffmpeg -i source.flv -ab 128k dest.mp3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一个爬虫程序]]></title>
      <url>%2F2016%2F10%2F26%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[前言学习python一段时间了，也了解过爬虫，觉得甚是有趣，于是想自己动手试试，因此诞生了我的第一个爬虫。 环境使用pip安装beautifulsoup4(先翻墙，不然pip会报timeout错误),beautifulsoup省去了繁复的正则,使得开发起来更加友好。 sudo -H pip --default-timeout=100 install beautifulsoup4 实现以下程序主要实现了一个小功能即爬取链家网苏州工业园区100平以下的所有二手房房源，并且生成csv文件（可由excel打开）。 #!/usr/bin/python # -*- coding: utf-8 -*- import sys import time import requests import urllib2 import codecs reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) from bs4 import BeautifulSoup class houseInfo: def __init__(self,title = &apos;&apos;,address = &apos;&apos;,square =&apos; &apos;,huxing = &apos;&apos;,priceInfo = &apos;&apos;,unitPrice = &apos;&apos;,link = &apos;&apos;): self.title = title self.address = address self.square = square self.huxing = huxing self.priceInfo = priceInfo self.unitPrice = unitPrice self.link = link list = [] def grab(url): # 使用requests或者urllib2都可以 # request = urllib2.Request(url) # response = urllib2.urlopen(request) # plain_text = response.read() source_code = requests.get(url) plain_text = source_code.text soup = BeautifulSoup(plain_text,&quot;html.parser&quot;) list_soup = soup.find(&quot;ul&quot;, class_=&quot;house-lst&quot;).find_all(&apos;li&apos;); for item in list_soup: title = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).a.string address = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-1&quot;).find(&quot;div&quot;, class_=&quot;where&quot;).a.string square = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-1&quot;).find(&quot;div&quot;, class_=&quot;where&quot;).find_all(&apos;span&apos;)[2].string huxing = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-1&quot;).find(&quot;div&quot;, class_=&quot;where&quot;).find_all(&apos;span&apos;)[1].string priceInfo = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-3&quot;).find(&quot;div&quot;, class_=&quot;price&quot;).span.string unitPrice = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-3&quot;).find(&quot;div&quot;, class_=&quot;price-pre&quot;).string link = &apos;http://su.lianjia.com&apos;+item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).a.get(&apos;href&apos;) info = houseInfo(title,address,square,huxing,priceInfo,unitPrice) single = &apos;%s,%s,%s,%s,%s万,%s,%s\n&apos;%(title,address,square,huxing,priceInfo,unitPrice,link) list.append(single) for i in range(1, 23): page = &quot;http://su.lianjia.com/ershoufang/gongyeyuan/d{0}p1/&quot;.format(str(i)) grab(page) with open(&apos;data.csv&apos;, &apos;w&apos;) as f: for item in list: # BOM_UTF8是为了excel中文不乱码 f.write(codecs.BOM_UTF8.decode(&apos;utf-8&apos;)) f.write(item)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python打包可执行文件]]></title>
      <url>%2F2016%2F10%2F20%2Fpython%E6%89%93%E5%8C%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[PyInstaller 是一个用来将 Python 程序打包成一个独立可执行软件包，支持 Windows、Linux 和 Mac OS X。 InstallationPyInstaller is available on PyPI. You can install it through pip: pip install pyinstaller Tips: 必须翻墙，不然会因为timeout报错,可以加一些参数: sudo -H pip --default-timeout=100 install pyinstaller usage安装完pyinstaller之后就可以开始使用了。 使用pyinstaller生成可执行文件的方法 将依赖文件集中到一个文件夹： pyinstaller -D -w main.py 将所有依赖文件都打包到同一个可执行文件中： pyinstaller -F -w main.py 把main.py替换成你的主入口python文件即可。-w参数代表main.py是一个窗体程序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[objective-c的工程内使用swift类]]></title>
      <url>%2F2016%2F09%2F19%2Fobjective-c%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%86%85%E4%BD%BF%E7%94%A8swift%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[主要步骤：添加swift桥接,修改项目配置项。 具体步骤如下图： stackoverflow链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git rebase 合并多条commit]]></title>
      <url>%2F2016%2F08%2F18%2Fgit-rebase-%E5%90%88%E5%B9%B6%E5%A4%9A%E6%9D%A1commit%2F</url>
      <content type="text"><![CDATA[目的合并多次commit，保留一次commit信息 步骤查看git log 合并commit2,3,4, 226b17为commit1的hash值 git rebase -i 226b17 :wq :wq commit合并成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从git reset --hard中拯救代码]]></title>
      <url>%2F2016%2F08%2F02%2F%E4%BB%8Egit-reset-hard%E4%B8%AD%E6%8B%AF%E6%95%91%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[场景如果git add .后还未commit输入了git reset --hard,会发现缓存区和本地都没有了这些改动的纪录，因为用了--hard。 挽救由于每次git命令进行操作时git都会对相关文件进行快照,并通过一定形式把信息保存再.git/目录下。 由于此前我使用过git add .命令,因此当文件被放进暂存区时,快照信息对象就已经保存了，而实用git reset --hard之后,这些对象就变成了悬空文件对象(dangling blob)。 我们可以实用git fsck命令显示他们 git fsck：用于验证当前git仓库数据的有效性和一致性，能够显示那些”丢失”的commit、blob(文件)、tree等。 我们可以通过以下命令 git fsck --cache --unreachable $(git for-each-ref --format=&quot;%(objectname)&quot;) 我们得到一大堆blob的hash ID unreachable blob 907b308167f0880fb2a5c0e1614bb0c7620f9dc3 unreachable blob 72663d3adcf67548b9e0f0b2eeef62bce3d53e03 ... 接下来使用git show就能显示这些对象的内容了，例如git show 907b308。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[疲民之术[转载]]]></title>
      <url>%2F2016%2F08%2F01%2F%E7%96%B2%E6%B0%91%E4%B9%8B%E6%9C%AF-%E8%BD%AC%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[原文地址 作者：介子平 新浪博客 任何时代，人民都是被统治的基本因子。人民者，平时出力，战时卖命。崔永元概括曰：“用你当炮灰时，你是无畏的英勇战士。用你创造财富时，你是勤奋的劳动人民。用你当统治基础时，你是光荣的领导阶级。剥夺你的所有财富时，你是乐于奉献的无产者。分享社会财富时，你是体制外的闲杂人员。进行‘义务教育时’，你是非本地户籍暂住人口。疯狂维稳时，你是社会各类不安定因素。”其又谓黎民庶民、子民蒸民、生民草民、兆民平民，又谓苍生百姓、布衣白丁、匹夫群氓、赤子大众。 《商君书》有驭民五术：壹民、弱民、疲民，辱民，贫民。壹民：统一思想，垄断意识形态，实施愚民政策。弱民：民弱国强，国强民弱，治国之道，务在弱民。疲民：为民寻事，使之疲于奔命，不得消停，然后换来统治者的安稳；不停征战，更卒、正卒、戍卒，不停徭役，力役、杂役、军役，使民无暇顾及他事。辱民：使之匍匐于生计，毫无自尊自信，唆之相互检举揭发，终天生活于恐惧氛围。贫民：除却生存必须，剥夺余粮余财，人穷志短，马瘦毛长，只得依赖国家分给，否则便会饿死。五者若不灵，杀之。 制天下者，必先制民，历代统治者奉《商君书》为秘籍宝典，桑弘羊赞之：“功如丘山，名传后世。”王安石赋诗曰：“自古驱民在信诚，一言为重百金轻。今人未可非商鞅，商鞅能令政必行。” 1958年8月21日，毛泽东在北戴河会议上讲话：“民法和刑法那一类法律都不要了。民法刑法那样多条谁记得了？一搞大跃进，就没时间犯法了。”此即疲民之术。在其执政的28年间，大运动套小运动，小运动为大运动，一个运动未结，另一运动已始，大大小小五六十次，唐德刚便说：“毛当国28年，最大的特点就是搞‘运动’，中国老百姓简直可以说没有一时一刻不在胆战心惊的运动中讨生活。”此也疲民之术。人有张弛调剂，农有忙闲间歇，闲时，迎神赛社，赶集听戏，然在学大寨期间，惟剩一忙。耕耘收储自不必说，纵然天寒地冻之时，大搞农田水利建设，平整土地，熟田变生土，美其名曰海绵田，毁林开垦，填湖造地，生态为之破坏，美其名曰人定胜天。期间，送饭地头，送戏田间，只闻周文雍陈铁军刑场上举办过婚礼，却不知有将婚礼办到水库工地上者。捆绑农民于土地，使之不得自由迁徙，此仍疲民之术。 疲民身体的当间，还树立起了若干劳模，号召众人学习之。工业学大庆，农业学大寨，全国学人民解放军。解放军里的先进人物最多，雷锋王杰刘英俊，除去做好事救财产，共同的一点是均毕业于“毛泽东思想大学校”，《毛选》学得好。此外，各行各业各树各的先进，周恩来便欣然道：“天涯处处有芳草，祖国处处有英雄。”有歌唱道：“革命熔炉火最红，毛泽东时代出英雄。”仅大寨的模范人物就有陈永贵、郭凤莲、贾进才、宋立英等。知青中的模范人物更多，著名者有河北的邢燕子、江苏的董家耕、山西的蔡立坚、天津的侯隽等，后来每个省、每个县都树起了自己的模范。黑龙江的金训华名气最大，1969年8月，上海知青金训华在洪水激流中抢救国家财产英勇牺牲，这位知青用以生命为代价抢救的国家财产，原来只是两根电线杆子。之后学金训华成风，表现突出者，可回城可当兵，可推荐工农兵学员，还可巡回作报告，尤其对于那些家庭出生不好者，尚有为救羊羔、扑灭草原野火罹难者，总之，国家利益至上，财产比人命重要，与国家的存在相比，个人简直无足轻重。学先进，赶先进，乃疲民精神之术。精神疲民之要点，在于使民占心，无暇反思自省，无以判断是否。你一旦被别人的观点所左右，实已沦为别人的奴隶。鲁迅说：“做奴隶虽然不幸，但并不可怕，因为知道挣扎，毕竟还有挣脱的希望；若是从奴隶生活中寻出美来，赞叹、陶醉，就是万劫不复的奴才了。”不幸被鲁迅言中，多数人在奴隶生活中找到了乐趣。 基本因子，永远是芸芸莘莘，铺天盖地。以前的教育是“永作革命的螺丝钉”，后来不提“革命”了，就作社会的螺丝钉吧。当你步入社会后便发现，在国家这部巨型机器上，哪有作螺丝钉的机会，你就是块铺路的碎石，终日被人车来回碾压。付出许多，所获极少，工资不高，纳税不低。卫生部部长陈竺曾在“小崔说事”栏目接受崔永元采访时，侃侃而谈医疗改革成果之惠民：“我们免费为一位农村大妈做了白内障手术。当摘下纱布时，她能看见了，她千谢万谢，要感谢这次‘白内障患者复明工程’的项目！靠她自己，她一辈子也做不起手术。”崔永元反问道：“她辛苦一辈子，连个白内障手术都做不起，那她得恨谁呢？” 时下为买房买车，孩子受教育家人看大夫，似乎所有人都在忙忙碌碌，蝇营狗苟，民疲矣。阳光少年一旦计较起柴米油盐，顿已进入中年，诗意泯灭，功利遂滋，浪漫殆尽，世故成习。而“买房保值”“孩子不能输在起跑线上”之类的口号，概念疲民也。这个路线，那个教育，这个主义，那个引导，精神疲民也。无形较之有型，劳心较之劳力，更甚。 在一个设定好的笼子里，任何动作，都是别人期望的表演。提笼之人，就怕你闲着，闲出自省自察、嗜欲爱好来，闲出条分缕析、擘肌剖理来，该是怎样的杵逆不道？圣人早有箴言：“民可使由之，不可使知之。”韩惠王曾派手无寸铁的水利专家郑国，说服秦国兴修水利，意在疲秦而无暇顾及六国。然秦民早已习惯被疲，疲秦不成反利秦。然秦人连年征战，加之筑长城，修阿房，疲民之术终使天下疲民揭竿而起，亡秦者，秦民也。隋炀帝征辽东，挖运河，疲民无奈，篝火狐鸣，亡隋者，隋民也。 对民如此，对君亦然。仇士良檀权揽政20余年，先后杀二王、一妃、四宰相，甚至可当面指斥皇帝，唐文宗哀叹自己受家奴控制，不如亡国之君周赧王、汉献帝。仇士良的事君固位秘诀为：“天子不可令闲暇，暇必观书，见儒臣，则又纳谏，智深虑远，减玩好，省游幸，吾属恩且薄而权轻矣。为诸君计，莫若殖财货，盛鹰马，日以球猎声色蛊其心，极侈靡，使悦不知息，则必斥经术，阇外事，万机在我，恩泽权力欲焉往哉？”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode打包.a静态库step by step]]></title>
      <url>%2F2016%2F07%2F20%2FXcode%E6%89%93%E5%8C%85-a%E9%9D%99%E6%80%81%E5%BA%93step-by-step%2F</url>
      <content type="text"><![CDATA[库介绍库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。iOS中的静态库有 .a 和 .framework两种形式；动态库有.dylib 和 .framework 形式，后来.dylib动态库又被苹果替换成.tbd的形式。 静态库与动态库的区别静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。总结：同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。 创建.a静态库第一步，新建工程。一般使用工程名就使用库的名称，比如我这里用任意一个NSString的Category来创建静态库，我的工程名就取名为Tool，创建的.a静态库就是libTool.a。 第二步，删除系统默认创建的【Tool.h】和【Tool.m】文件，导入需要打包的源文件。 第三步，修改配置 左上角加号－&gt;【New Headers Phase】-&gt; 添加所有需要打包的头文件，如下图： 第四步，修改导出product配置 第五步，修改编译指令集 模拟器：iPhone4s~5 : i386 iPhone5s~6plus : x86_64真机：iPhone3gs~4s : armv7 iPhone5~5c : armv7s iPhone5s~6plus : arm64如果第五步这里，设置为YES，那么编译出来的.a静态库就只包含当前设备的指令集。举个例子：如果我们选择iPhone 5模拟器【Command+B】编译，则编译出来的.a静态库只能用iPhone4s~5模拟器跑程序，用iPhone5s~6plus，则会报找不到x86_64的libTool库。设置为NO，则会把所有指令集的都打包合并。 第六步，编译（快捷键【Command+B】编译时，需要用模拟器和真机各编译一次，这样Products目录下的libTool.a静态库才会变为黑色，右键show in Finder，可以进入Products目录下。 注意：如果步骤四中，不将Build Configuration改为Release,则打包出来的静态库会存于【Debug-iphoneos】和【Debug-iphonesimulator】两个文件夹下。我们一般都使用Release模式，因为程序最终发布之后是Release版的，所以静态库也是在Release模式下使用。 如果想要通用需要将模拟器使用的静态库与真机使用的静态库合并成一个静态库，可以使用终端命令来实现。命令格式：lipo -create 第一个.a文件的绝对路径 第二个.a文件的绝对路径 -output 最终的.a文件路径。本文中使用的命令如下： lipo -create /Users/paul/Library/Developer/Xcode/DerivedData/Tool-fcimdkyxyorzxoafjvdaenioayfh/Build/Products/Release-iphoneos/libTool.a /Users/paul/Library/Developer/Xcode/DerivedData/Tool-fcimdkyxyorzxoafjvdaenioayfh/Build/Products/Release-iphonesimulator/libTool.a -output /Users/paul/Desktop/libTool.a 补充：经过多次实践，第三步的操作省略，依然可以导出可正常使用的包。如果静态库中有category类，则在使用静态库的项目配置中【Other Linker Flags】需要添加参数【-ObjC】或者【-all_load】。 最后，将生成的.a文件以及相应include文件引入即可使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 9 全新Contacts Framework解析]]></title>
      <url>%2F2016%2F07%2F18%2FiOS-9-%E5%85%A8%E6%96%B0Contacts%20Framework%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[引言在以前iOS开发中，涉及联系人相关的编程，代码都非常繁琐，并且框架的设计也不是Objective-C风格的，这使开发者用起来非常的难受。在iOS9中，apple终于解决了这个问题，全新的Contacts Framework将完全替代AddressBookFramework，AddressBookFramework也将成为历史被弃用。 Contact框架的使用 CNContact基本属性 /** * 设置联系人的基本属性 * * @return 返回联系人的对象 */ - (CNMutableContact *)initializeContact{ // 创建联系人对象 CNMutableContact *contact = [[CNMutableContact alloc] init]; // 设置联系人的头像 contact.imageData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;7677360.png&quot;]); // 设置联系人姓名 contact.givenName = @&quot;伟君&quot;; // 设置姓氏 contact.familyName = @&quot;丁&quot;; // 设置联系人邮箱 CNLabeledValue *homeEmail = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:@&quot;12345qq.com&quot;]; CNLabeledValue *workEmail = [CNLabeledValue labeledValueWithLabel:CNLabelWork value:@&quot;32467@sina.cn&quot;]; CNLabeledValue *otherEmail = [CNLabeledValue labeledValueWithLabel:CNLabelOther value:@&quot;lanaj.com&quot;]; contact.emailAddresses = @[homeEmail,workEmail,otherEmail]; // 设置机构名 contact.organizationName = @&quot;互联网&quot;; // 设置部门 contact.departmentName = @&quot;IT&quot;; // 设置工作的名称 contact.jobTitle = @&quot;ios&quot;; // 设置社会的简述 CNSocialProfile *profile = [[CNSocialProfile alloc] initWithUrlString:@&quot;12306.cn&quot; username:@&quot;Paul&quot; userIdentifier:nil service:@&quot;IT行业&quot;]; CNLabeledValue *socialProfile = [CNLabeledValue labeledValueWithLabel:CNSocialProfileServiceGameCenter value:profile]; contact.socialProfiles = @[socialProfile]; // 设置电话号码 CNPhoneNumber *mobileNumber = [[CNPhoneNumber alloc] initWithStringValue:@&quot;18500000000&quot;]; CNLabeledValue *mobilePhone = [[CNLabeledValue alloc] initWithLabel:CNLabelPhoneNumberMobile value:mobileNumber]; contact.phoneNumbers = @[mobilePhone]; // 设置与联系人的关系 CNContactRelation *friend = [[CNContactRelation alloc] initWithName:@&quot;好基友&quot;]; CNLabeledValue *relation = [CNLabeledValue labeledValueWithLabel:CNLabelContactRelationFriend value:friend]; contact.contactRelations = @[relation]; // 设置生日 NSDateComponents *birthday = [[NSDateComponents alloc] init]; birthday.day = 6; birthday.month = 5; birthday.year = 2000; contact.birthday = birthday; return contact; } CNSaveRequest使用 @interface CNSaveRequest : NSObject //添加一个联系人 - (void)addContact:(CNMutableContact *)contact toContainerWithIdentifier:(nullable NSString *)identifier; //更新一个联系人 - (void)updateContact:(CNMutableContact *)contact; //删除一个联系人 - (void)deleteContact:(CNMutableContact *)contact; //添加一组联系人 - (void)addGroup:(CNMutableGroup *)group toContainerWithIdentifier:(nullable NSString *)identifier; //更新一组联系人 - (void)updateGroup:(CNMutableGroup *)group; //删除一组联系人 - (void)deleteGroup:(CNMutableGroup *)group; //向组中添加子组 - (void)addSubgroup:(CNGroup *)subgroup toGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA); //在组中删除子组 - (void)removeSubgroup:(CNGroup *)subgroup fromGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA); //向组中添加成员 - (void)addMember:(CNContact *)contact toGroup:(CNGroup *)group; //向组中移除成员 - (void)removeMember:(CNContact *)contact fromGroup:(CNGroup *)group; @end CNSaveRequest的封装使用 /** * 在group里删除成员 * * @param contact 被删除的联系人 * @param group 在该group里删除联系人 */ - (void)deleteMemberWithContact:(CNContact *)contact toGroup:(CNGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest removeMember:contact fromGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 向group添加成员 * * @param contact 被添加的联系人 * @param group 添加到该group */ - (void)addMemberWithContact:(CNContact *)contact toGroup:(CNGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest addMember:contact toGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 更新group * * @param group 被更新的group */ - (void)updateGroup:(CNMutableGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest updateGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 删除group操作 * * @param group 被删除的group */ - (void)deleteWithGroup:(CNMutableGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest deleteGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 查询 * * @return 返回数组 */ - (NSArray *)queryGroup{ CNContactStore *store = [[CNContactStore alloc] init]; // 查询所有的group(predicate参数为空时会查询所有的group) NSArray *arr = [store groupsMatchingPredicate:nil error:nil]; return arr; } /** * 添加群组 * * @param name 群组的名称 */ - (void)addGroupWithName:(NSString *)name{ CNMutableGroup *group = [[CNMutableGroup alloc] init]; group.name = name; CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest addGroup:group toContainerWithIdentifier:nil]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 查询操作 * * @return 返回数组 */ - (NSArray *)queryContactWithName:(NSString *)name{ CNContactStore *store = [[CNContactStore alloc] init]; // 检索条件 NSPredicate *predicate = [CNContact predicateForContactsMatchingName:name]; // 提取数据 （keysToFetch:@[CNContactGivenNameKey]是设置提取联系人的哪些数据） NSArray *contact = [store unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey] error:nil]; return contact; } /** * 更新联系人 * * @param contact 被更新的联系人 */ - (void)updateContact:(CNMutableContact *)contact{ // 创建联系人请求 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest updateContact:contact]; // 重新写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 删除联系人 * * @param contact 被删除的联系人 */ - (void)deleteContact:(CNMutableContact *)contact{ // 创建联系人请求 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest deleteContact:contact]; // 写入操作 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 添加联系人 * * @param contact 联系人 */ - (void)addContact:(CNMutableContact *)contact{ // 创建联系人请求 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest addContact:contact toContainerWithIdentifier:nil]; // 写入联系人 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } 实际工程中的操作使用 - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a ni CNMutableContact *contact = [self initializeContact]; //添加联系人 [self addContact:contact]; //查询 NSArray *arr = [self queryContactWithName:@&quot;伟君&quot;]; //将不可变的CNContact转成CNMutableContact，便可执行以下操作 CNMutableContact *contact = [arr[0] mutableCopy]; //更新 contact.givenName = @&quot;大力&quot;; [self updateContact:contact]; //删除 [self deleteContact:contact]; //添加群组 [self addGroupWithName:@&quot;Yudo&quot;]; //返回所有数组 NSArray *array = [self queryGroup]; NSLog(@&quot;==%@&quot;,array); //删除group操作 CNMutableGroup *group = [array[2] mutableCopy]; [self deleteWithGroup:group]; //更新group CNMutableGroup *group = [array[2] mutableCopy]; group.name = @&quot;Yudo&quot;; [self updateGroup:group]; //向group添加成员 NSArray *results = [self queryContactWithName:@&quot;伟君&quot;]; for (int i=0; i&lt;array.count; i++) { CNGroup *group=array[i]; if ([group.name isEqualToString:@&quot;Yudo&quot;]) { [self addMemberWithContact:results[0] toGroup:group]; } } //在group里删除成员 NSArray *results = [self queryContactWithName:@&quot;baba zhang&quot;]; for (int i=0; i&lt;array.count; i++) { CNGroup *group=array[i]; if ([group.name isEqualToString:@&quot;Yudo&quot;]) { [self deleteMemberWithContact:results[0] toGroup:group]; } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用CAShaperLayer绘制气泡]]></title>
      <url>%2F2016%2F07%2F12%2F%E5%88%A9%E7%94%A8CAShaperLayer%E7%BB%98%E5%88%B6%E6%B0%94%E6%B3%A1%2F</url>
      <content type="text"><![CDATA[实现机制在每一View的layer层中有一个mask属性，他就是专门来设置该View的遮罩效果的。该mask本身也是一个layer层。我们只需要生成一个自定义的layer，然后覆盖在需要遮罩的View上面即可。问题就归于如何生成入上图所示的不规则图片的Layer。CAShapeLayer可以根据几个点的依次连线，产生一个闭合空间的layer。 实现方法 实现一个CAShapeLayer的Category。 + (instancetype)createMaskLayerWithView : (UIView *)view{ CGFloat viewWidth = CGRectGetWidth(view.frame); CGFloat viewHeight = CGRectGetHeight(view.frame); CGFloat rightSpace = 10; CGFloat topSpace = 10; CGFloat radius = 10; CGPoint point1 = CGPointMake(0, radius); CGPoint point2 = CGPointMake(radius, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace-radius, 0); CGPoint point4 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point5 = CGPointMake(viewWidth, topSpace); CGPoint point6 = CGPointMake(viewWidth-rightSpace, topSpace+10); CGPoint point7 = CGPointMake(viewWidth-rightSpace, viewHeight-radius); CGPoint point8 = CGPointMake(viewWidth-rightSpace-radius, viewHeight); CGPoint point9 = CGPointMake(radius, viewHeight); CGPoint point10 = CGPointMake(0, viewHeight-radius); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addArcWithCenter:CGPointMake(radius, radius) radius:radius startAngle:M_PI endAngle:M_PI*1.5 clockwise:YES]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addArcWithCenter:CGPointMake(viewWidth-2*radius, radius) radius:radius startAngle:M_PI*1.5 endAngle:0 clockwise:YES]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path addArcWithCenter:CGPointMake(viewWidth-2*radius, viewHeight-radius) radius:radius startAngle:0 endAngle:M_PI*0.5 clockwise:YES]; [path addLineToPoint:point8]; [path addLineToPoint:point9]; [path addArcWithCenter:CGPointMake(radius, viewHeight-radius) radius:radius startAngle:M_PI*0.5 endAngle:M_PI clockwise:YES]; [path addLineToPoint:point10]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = path.CGPath; return layer; } UIView *view = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 40)]; view.backgroundColor = [UIColor orangeColor]; CAShapeLayer *layer = [CAShapeLayer createMaskLayerWithView:view]; view.layer.mask = layer; [self.view addSubview:view]; 参数说明center：Specifies the center point of the circle (in the current coordinate system) used to define the arc. radius：Specifies the radius of the circle used to define the arc. startAngle： Specifies the starting angle of the arc (measured in radians). endAngle：Specifies the end angle of the arc (measured in raians). clockwise：The direction in which to draw the arc. 实现效果如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS大文件下载遇上nginx反向代理]]></title>
      <url>%2F2016%2F07%2F08%2FiOS%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%81%87%E4%B8%8Anginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[内网部署nginx，直接挂上2g多的zip包，iOS下载正常，将zip包挂到公司服务器，下载到49.1%（差不多1.07G）就中断链接，于是就各种猜测原因。 文件下载代码写的有问题？ NSURLSessionDownload,NSURLConnection,AFN换了个遍都一样,虽然没有找到原因，但是发现NSURLSessionDownload下载时占用内存比NSURLConnection少，机制更优。 服务器的问题？ 安卓可以正常下载，windows浏览器可以正常下载，safari下载到49.1%同样网络中断？what？开始抓包，发现没有异常，只有nginx版本不一样，后来发现公司服务器用了反向代理。 google后尝试写改配置nginx.conf，关闭buffer，proxy_buffering off，可以正常下载了。再尝试开启buffer，然后配置相关参数，也能正常下载，下载的速度和配置的参数有关系，配置参考如下: proxy_cache参数配置文件/usr/local/nginx/conf/proxy.conf proxy_temp_path /home/proxy_temp_dir; proxy_cache_path /home/proxy_cache_dir levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=30g; client_body_buffer_size 512k; proxy_connect_timeout 60; proxy_read_timeout 60; proxy_send_timeout 60; proxy_buffer_size 32k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; proxy_next_upstream error timeout invalid_header http_500 http_503 http_404; proxy_cache cache_one; 至此事情告一段落。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Start NexT]]></title>
      <url>%2F2016%2F05%2F24%2FStart-NexT%2F</url>
      <content type="text"><![CDATA[NexT使用文档 如何将文章分类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F05%2F24%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
