<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[机器学习]]></title>
      <url>%2F2017%2F05%2F17%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[什么是机器学习?Two definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition.” Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.“ Example: playing checkers. E = the experience of playing many games of checkers T = the task of playing checkers. P = the probability that the program will win the next game. In general, any machine learning problem can be assigned to one of two broad classifications: Supervised learning（监督学习） and Unsupervised learning（无监督学习）. 监督学习在监督学习中，我们获得了一个数据集，并且已经知道我们正确的输出应该是什么样子的，这意味着输入和输出之间有一个关系。 受监督的学习问题分为“回归”和“分类”问题。在回归问题中，我们试图在连续输出中预测结果，这意味着我们正在尝试将输入变量映射到一些连续函数。在分类问题中，我们试图用离散输出来预测结果。换句话说，我们正在尝试将输入变量映射到离散类别。 Example1: 根据房地产市场规模的数据，尝试预测房价。价格作为大小的函数是连续的输出，所以这是一个回归问题。 我们可以将这个例子变成一个分类问题，而不是让我们的产出是关于房子“卖出多于或者低于要价”。在这里，我们将房价分为两类。 Example2: 回归 - 鉴别一个人的图片，我们必须根据给定的图片来预测他们的年龄. 分类 - 鉴别肿瘤患者，我们必须预测肿瘤是恶性还是良性。 无监督学习无监督学习使我们能够很少或不知道我们的结果应该如何处理问题。我们可以从数据中导出结构，我们不一定知道变量的影响。 我们可以通过基于数据中的变量之间的关系对数据进行聚类来导出该结构。 通过无监督的学习，基于预测结果没有反馈。 Example: 聚类：收集100万个不同的基因，并找到一种自动将这些基因组合成不同变量（如生命周期，位置，作用等）相似或相关的组。 非聚类：“鸡尾酒会算法”，让您在混乱的环境中找到结构。 （即，从鸡尾酒会的声音网格中识别个体声音和音乐）。 代价函数我们可以使用代价函数来衡量我们的假设函数的准确性。这取决于x的输入和实际输出y的假设的所有结果的平均差异（实际上是平均值的平均值）。 此功能也称为“平方误差函数”或“均方误差”。平均值减半（12）作为计算梯度下降的便利，因为平方函数的导数项将抵消12项。以下图片总结了成本函数的作用： 轮廓图是包含许多轮廓线的图形。两个可变函数的轮廓线在同一行的所有点都具有一个恒定值。这样的图表的例子是下面的图。 采取任何颜色，沿着“圆”走，人们期望得到相同的成本函数值。例如，上面绿线上发现的三个绿点与J（θ0，θ1）具有相同的值，因此它们沿同一行找到。当θ0= 800和θ1= -0.15时，圆圈x显示左侧图形的成本函数值。再取另一个h（x）并绘制其轮廓图，得到以下图形： 当θ0= 360和θ1= 0时，轮廓图中J（θ0，θ1）的值越接近中心，从而降低成本函数误差。现在给出我们的假设函数稍微正斜率导致更好的数据拟合。 上面的图表尽可能地最小化了成本函数，因此θ1和θ0的结果分别为0.12和250左右。将图表上的这些值绘制到右边似乎将我们的观点置于内部最“圆”的中心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios10相册等隐私权限设置]]></title>
      <url>%2F2016%2F12%2F20%2Fios10%E7%9B%B8%E5%86%8C%E7%AD%89%E9%9A%90%E7%A7%81%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[崩溃日志示例： This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data. 升到iOS10之后，需要在info.plist设置权限的有： 麦克风权限：Privacy - Microphone Usage Description 是否允许此App使用你的麦克风？ 相机权限： Privacy - Camera Usage Description 是否允许此App使用你的相机？ 相册权限： Privacy - Photo Library Usage Description 是否允许此App访问你的媒体资料库？ 通讯录权限： Privacy - Contacts Usage Description 是否允许此App访问你的通讯录？ 蓝牙权限：Privacy - Bluetooth Peripheral Usage Description 是否许允此App使用蓝牙？ 语音转文字权限：Privacy - Speech Recognition Usage Description 是否允许此App使用语音识别？ 日历权限：Privacy - Calendars Usage Description 定位权限：Privacy - Location When In Use Usage Description 定位权限: Privacy - Location Always Usage Description 位置权限：Privacy - Location Usage Description 媒体库权限：Privacy - Media Library Usage Description 健康分享权限：Privacy - Health Share Usage Description 健康更新权限：Privacy - Health Update Usage Description 运动使用权限：Privacy - Motion Usage Description 音乐权限：Privacy - Music Usage Description 提醒使用权限：Privacy - Reminders Usage Description Siri使用权限：Privacy - Siri Usage Description 电视供应商使用权限：Privacy - TV Provider Usage Description 视频用户账号使用权限：Privacy - Video Subscriber Account Usage Description]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Python给图片打马赛克]]></title>
      <url>%2F2016%2F12%2F02%2F%E5%88%A9%E7%94%A8Python%E7%BB%99%E5%9B%BE%E7%89%87%E6%89%93%E9%A9%AC%E8%B5%9B%E5%85%8B%2F</url>
      <content type="text"><![CDATA[思路利用PIL(Python Image Library)获取图片相应点位的像素值，然后以这些像素为基础重新绘制一张新图。 实现#!/Library/anaconda/bin/python # -*- coding: utf-8 -*- # 实现功能: 给图片打马赛克 from PIL import Image, ImageDraw, ImageFont import sys width = 600 height = 600 granularity = 25 # 颗粒度 image = Image.new(&apos;RGB&apos;, (width, height), (255, 255, 255)) # 创建Font对象: font = ImageFont.truetype(&apos;Arial.ttf&apos;, 36) # 创建Draw对象: draw = ImageDraw.Draw(image) # image_name = raw_input(&apos;Entering Input ImageName: &apos;) image_name = sys.argv[1] image_file = Image.open(image_name) image_file = image_file.resize((width, height)) # 调整图片大小 def to_mosaic(file_name): for x in range(0, width, granularity): for y in range(0, height, granularity): r, g, b = file_name.getpixel((x, y)) draw.rectangle([(x, y), (x + granularity, y + granularity)], fill=(r, g, b), outline=None) # None即是不加网格 to_mosaic(image_file) image.save(&apos;Mosaic.jpg&apos;, &apos;jpeg&apos;) 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS启动服务浅析]]></title>
      <url>%2F2016%2F11%2F29%2FMac-OS%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[起因之所以分析Mac OS启动项，主要原因是我下载visio for Mac时中了一招，下载到了李鬼，是个pkg文件，安装时提示我可能损害电脑，但是我还是授权了，结果悲剧了。 后果chrome和firefox首页全部被篡改为名叫snowbitt的搜索引擎，开机后safari和firefox都被默认启动。 解决办法首页篡改还是比较容易，比如chrome中 setting-&gt;重制设置即可，不过它会关闭所有插件，重新打勾开启，然后把启动时网页改过来即可。firefox中直接删相应搜索引擎项无用，只能卸载掉并把／Library/Application Support/Firefox 文件删掉，然后下载新的dmg文件重装即可。 比较麻烦的是开机启动项，系统偏好设置里明明没有启动项，可是开机时还是会启动，于是就深究了下去，发现和Mac OS启动服务有关系。 我们先来看一下Mac OS X的启动原理： mac固件激活，初始化硬件，加载BootX引导器。 BootX加载内核与内核扩展(kext)。 内核启动launchd进程。 launchd根据/System/Library/LaunchAgents, /System/Library/LaunchDaemons, /Library/LaunchDaemons,/Library/LaunchAgents,~/Library/LaunchAgents,里的plist配置，启动服务守护进程。 下面再来理解几个基础概念： /System/Library和/Library和~/Library目录的区别？ /System/Library目录是存放Apple自己开发的软件。/Library目录是系统管理员存放的第三方软件。~/Library/是用户自己存放的第三方软件。 LaunchDaemons和LaunchAgents的区别？ LaunchDaemons是用户未登陆前就启动的服务（守护进程）。LaunchAgents是用户登陆后启动的服务（守护进程）。 以上所说的plist文件大致格式如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd &gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.example.exampled&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;exampled&lt;/string&gt; &lt;/array&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; 集体参数含义参照Apple官方文档launchd.plist 我进入相应目录，根据最新更新日期，发现新增了几个plist文件，cat下，其中关注到了两个关键参数 KeepAlive: True 进程一直存在 RunAtLoad: True 进程开机就启动 ProgramArguments: /etc/run_app.sh 查看了run_app.sh也是个新增的脚本文件，并存在于/etc目录下面 看了代码大概意思就是10s后开启了某些应用，并篡改了www.google.com 到此破案了，我删除了相关多余plist文件和run_app.sh，重启电脑就正常了，当然把相应参数改为false也是可以的，由于我不需要run_app.sh这个脚本，所以索性彻底删除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pool - Python多进程管理]]></title>
      <url>%2F2016%2F11%2F28%2FPool-Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[在Python中多进程管理使用Pool,可以设定最大进程数n，一次执行n个任务，当有一个进程完成后会有新的进程被添加进Pool。 示例代码： import multiprocessing import os, time, random def Lee(): print &quot;Run task Lee - %s&quot; % (os.getpid()) # os.getpid()获取当前的进程的ID start=time.time() time.sleep(random.random()*10) # random.random()随机生成0-1之间的小数 end=time.time() print &apos;Task Lee, runs %0.2f seconds.&apos; %(end - start) def Marlon(): print &quot;Run task Marlon - %s&quot; % (os.getpid()) start = time.time() time.sleep(random.random()*40) end = time.time() print &apos;Task Marlon runs %0.2f seconds.&apos; % (end - start) def Allen(): print &quot;Run task Allen - %s&quot; % (os.getpid()) start = time.time() time.sleep(random.random()*30) end = time.time() print &apos;Task Allen runs %0.2f seconds.&apos; % (end - start) def Frank(): print &quot;Run task Frank - %s&quot; % (os.getpid()) start = time.time() time.sleep(random.random()*20) end = time.time() print &apos;Task Frank runs %0.2f seconds.&apos; % (end - start) if __name__ == &apos;__main__&apos;: function_list = [Lee, Marlon, Allen, Frank] print &quot;parent process %s&quot; % (os.getpid()) pool = multiprocessing.Pool(2) for func in function_list: pool.apply_async(func) # Pool执行函数，apply执行函数,当有一个进程执行完毕后，会添加一个新的进程到pool中 print &apos;Waiting for all subprocesses done...&apos; pool.close() pool.join() # 调用join之前，一定要先调用close() 函数，否则会出错, close()执行后不会有新的进程加入到pool,join函数等待素有子进程结束 print &apos;All subprocesses done.&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python单例的4种实现方法]]></title>
      <url>%2F2016%2F11%2F28%2FPython%E5%8D%95%E4%BE%8B%E7%9A%844%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[方法一实现__new__方法并在将一个类的实例绑定到类变量_instance上,如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回如果cls._instance不为None,直接返回cls._instance class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, &apos;_instance&apos;): cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instance class A(Singleton): def __init__(self, s, v): self.s = s self.v = v a = A(1, 5) b = A(2, 4) print id(a), a.s print id(b), b.v &quot;&quot;&quot; import borg 其他文件调用borg的A类的实例即可调用其属性 eg: print borg.a.s print borg.b.v &quot;&quot;&quot; 方法二共享模式;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)同一个类的所有实例天然拥有相同的行为(方法),只需要保证同一个类的所有实例具有相同的状态(属性)即可所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict) Tips: 这是一种特殊的单例方式,多个实例对象共享属性a singleton with shared-state among instances class Borg: __shared_state = {} def __init__(self): self.__dict__ = self.__shared_state self.state = &apos;Init&apos; def __str__(self): return self.state class YourBorg(Borg): pass if __name__ == &apos;__main__&apos;: rm1 = Borg() rm2 = Borg() rm1.state = &apos;Idle&apos; rm2.state = &apos;Running&apos; print(&apos;rm1: {0}&apos;.format(rm1)) print(&apos;rm2: {0}&apos;.format(rm2)) rm2.state = &apos;Zombie&apos; print(&apos;rm1: {0}&apos;.format(rm1)) print(&apos;rm2: {0}&apos;.format(rm2)) print(&apos;rm1 id: {0}&apos;.format(id(rm1))) print(&apos;rm2 id: {0}&apos;.format(id(rm2))) rm3 = YourBorg() print(&apos;rm1: {0}&apos;.format(rm1)) print(&apos;rm2: {0}&apos;.format(rm2)) print(&apos;rm3: {0}&apos;.format(rm3)) 方法三本质上是方法1的升级（或者说高级版)使用__metaclass__（元类）的高级python用法 class Basic(type): def __init__(cls, *args, **kwargs): super(Basic, cls).__init__(*args, **kwargs) def __new__(cls, *args, **kwargs): return super(Basic, cls).__new__(cls, *args, **kwargs) class Foo: __metaclass__ = Basic Foo.color = &apos;red&apos; Foo.borderWidth = 1 class rect: def __init__(self, color, borderWidth): self.color = color self.borderWidth = borderWidth if __name__ == &apos;__main__&apos;: Foo.color = &apos;blue&apos; a = rect(Foo.color, Foo.borderWidth) print a.__dict__ &quot;&quot;&quot; from borg import Foo 其他文件调用Foo类的属性即可 eg: print Foo.color print Foo.borderWidth &quot;&quot;&quot; 方法四使用装饰器(decorator),这是一种更pythonic,更elegant的方法,单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的 def singleton(cls, *args, **kw): instances = {} def _singleton(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return _singleton @singleton class MyClass(object): a = 1 def __init__(self, x=0): self.x = x one = MyClass() two = MyClass() two.a = 3 print one.a # 3 print id(one) # 29660784 print id(two) # 29660784 print one == two # True print one is two # True one.x = 1 print one.x # 1 print two.x # 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抽象工厂和builder模式的区别]]></title>
      <url>%2F2016%2F11%2F24%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%92%8Cbuilder%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[在工厂模式里，我们无需关心产品的各部分是如何被创建的，但在Builder模式里，会把产品的创建过程抽象为多个部分。也就是说工厂模式被关注的是整个产品，而Builder模式被关注的是产品的组成部分的创建过程。 Builder模式的类图: Factory模式一进一出,Builder模式是分步流水线作业。当你需要做一系列有序的工作或者按照一定的逻辑来完成创建一个对象时 Builder就派上用场啦。 我们可以看到，Builer模式与工厂模式是极为相似的，但是他们还是有区别的： 一、从结构上来看，Builder模式比工厂模式多了一个“导演类”的角色。在Builder模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。 二、两者所创建的产品类型完全不一样。Factory创建只能是单一的产品(单一在这指它非复合产品),而Builder所创建的产品是复合产品，即产品本身就是由其它部件产品组成的。 举个例子来说，现在要生产一辆车，假设它就只由这三个部分组成：玻璃、轮子、发动机。对于工厂模式来说，他创建后返回的，只能是玻璃，或者轮子，抑或是发动机。不管怎么样，他不能向客户返回一辆完整的汽车，要得到一辆完整的汽车，客户必须自己动手去把这些零部件组装成一辆汽车。从这个意义上来讲，工厂模式中的工厂，只是充当了零件厂的角色。那Builder又是如何创建产品的呢？在Builder模式中，一般不需要、也不充许向客户返回单个部件，他向客户返回的，仅仅就是一部已经完全组装好的汽车成品。对于汽车部件的生产细节，客户不需要、也不应该让他们知道。 三、Builder和Factory的差别，还在于他们所生产部件产品所在产品树的问题。这样说，可能有点拗口。具体来说吧，在工厂模式中，我们知道，一个工厂可以创建多个产品，但一个工厂模式中所创建的某个产品，都会和另一个工厂中所创建的产品在同一棵继承树上。Builder可以创建出可以创建出风马不相及的产品(虽然我们不这么做)，但是Factory模式一般是创建一类产品。 以下贴两端Python的抽象工厂和Builder模式的经典代码: 抽象工厂#!/usr/bin/env python # -*- coding: utf-8 -*- #http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/ &quot;&quot;&quot;Implementation of the abstract factory pattern&quot;&quot;&quot; import random class PetShop: &quot;&quot;&quot;A pet shop&quot;&quot;&quot; def __init__(self, animal_factory=None): &quot;&quot;&quot;pet_factory is our abstract factory. We can set it at will.&quot;&quot;&quot; self.pet_factory = animal_factory def show_pet(self): &quot;&quot;&quot;Creates and shows a pet using the abstract factory&quot;&quot;&quot; pet = self.pet_factory.get_pet() print(&quot;We have a lovely {}&quot;.format(pet)) print(&quot;It says {}&quot;.format(pet.speak())) print(&quot;We also have {}&quot;.format(self.pet_factory.get_food())) # Stuff that our factory makes class Dog: def speak(self): return &quot;woof&quot; def __str__(self): return &quot;Dog&quot; class Cat: def speak(self): return &quot;meow&quot; def __str__(self): return &quot;Cat&quot; # Factory classes class DogFactory: def get_pet(self): return Dog() def get_food(self): return &quot;dog food&quot; class CatFactory: def get_pet(self): return Cat() def get_food(self): return &quot;cat food&quot; # Create the proper family def get_factory(): &quot;&quot;&quot;Let&apos;s be dynamic!&quot;&quot;&quot; return random.choice([DogFactory, CatFactory])() # Show pets with various factories if __name__ == &quot;__main__&quot;: for i in range(3): shop = PetShop(get_factory()) shop.show_pet() print(&quot;=&quot; * 20) ### OUTPUT ### # We have a lovely Dog # It says woof # We also have dog food # ==================== # We have a lovely Dog # It says woof # We also have dog food # ==================== # We have a lovely Cat # It says meow # We also have cat food # ==================== Builder模式#!/usr/bin/python # -*- coding : utf-8 -*- &quot;&quot;&quot; @author: Diogenes Augusto Fernandes Herminio &lt;diofeher@gmail.com&gt;https://gist.github.com/420905#file_builder_python.py &quot;&quot;&quot; # Director class Director(object): def __init__(self): self.builder = None def construct_building(self): self.builder.new_building() self.builder.build_floor() self.builder.build_size() def get_building(self): return self.builder.building # Abstract Builder class Builder(object): def __init__(self): self.building = None def new_building(self): self.building = Building() def build_floor(self): raise NotImplementedError def build_size(self): raise NotImplementedError # Concrete Builder class BuilderHouse(Builder): def build_floor(self): self.building.floor = &apos;One&apos; def build_size(self): self.building.size = &apos;Big&apos; class BuilderFlat(Builder): def build_floor(self): self.building.floor = &apos;More than One&apos; def build_size(self): self.building.size = &apos;Small&apos; # Product class Building(object): def __init__(self): self.floor = None self.size = None def __repr__(self): return &apos;Floor: {0.floor} | Size: {0.size}&apos;.format(self) # Client if __name__ == &quot;__main__&quot;: director = Director() director.builder = BuilderHouse() director.construct_building() building = director.get_building() print(building) director.builder = BuilderFlat() director.construct_building() building = director.get_building() print(building) ### OUTPUT ### # Floor: One | Size: Big # Floor: More than One | Size: Small]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用python编写简单的登陆API]]></title>
      <url>%2F2016%2F11%2F14%2F%E4%BD%BF%E7%94%A8python%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E9%99%86API%2F</url>
      <content type="text"><![CDATA[框架Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。 思路利用Flask,通过和数据库校验用户名密码来判断是否可以登陆成功。 实现#!/usr/bin/python # -*- coding: utf-8 -*- from flask import Flask, request, render_template, Response import MySQLdb import json app = Flask(__name__) @app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def login(): if request.method == &apos;POST&apos;: if valid_login(request.form[&apos;username&apos;], request.form[&apos;password&apos;]): return json.dumps({&apos;status&apos;: 1, &apos;data&apos;: &apos;login success&apos;}) else: error = &apos;Invalid username/password&apos; return error else: return &apos;Not Support Get&apos; def valid_login(username,password): conn = MySQLdb.connect( host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, # passwd=&apos;&apos;, db=&apos;Test&apos; ) cur = conn.cursor() resp = [] try: sql = &quot;select * from user where name = &apos;%s&apos; and password = &apos;%s&apos;&quot; % (username, password) cur.execute(sql) resp = cur.fetchall() conn.commit() except Exception as e: print e conn.rollback() cur.close() conn.close() return len(resp) if __name__ == &apos;__main__&apos;: app.run(host=&quot;127.0.0.1&quot;, port=8080, debug=True) 部署pycharm运行xxx.py即可 * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger pin code: 273-703-379 Mac默认开启apache服务占用了80端口，所以这边暂时使用8080作为测试端口在本地测试。 小结用Python写Restful风格的webAPI其实蛮方便，也容易部署，小项目容易上手，本文所写API只为好玩，真实项目要考虑更多的东西，比如加密等等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python图片转字符串画]]></title>
      <url>%2F2016%2F11%2F11%2Fpython%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%BB%2F</url>
      <content type="text"><![CDATA[原理把图片各像素根据灰度值转成不同的自定义字符串然后显示出来。 依赖库使用第三方库pillow: sudo -H pip --default-timeout=100 install pillow 实现#!/usr/bin/python # -*- coding: utf-8 -*- from PIL import Image ascii_char = list(&quot;##$&amp; &quot;) count = len(ascii_char) def toText(image_file): string = &apos;&apos; for h in range(0, image_file.size[1]): # h for w in range(0, image_file.size[0]): # w r, g, b = image_file.getpixel((w, h)) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = 255.0 / len(ascii_char) string = string + ascii_char[int(gray / unit)] string = string + &apos;\n&apos; return string image_file = Image.open(&quot;lks.jpg&quot;) image_file = image_file.resize((int(image_file.size[0]*0.2), int(image_file.size[1] * 0.1))) # 调整图片大小 print u&apos;Info:&apos;, image_file.size[0], &apos; &apos;, image_file.size[1], &apos; &apos;, count with open(&apos;lks.txt&apos;,&apos;w&apos;) as f: f.write(toText(image_file)) 效果图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL注入原理浅析]]></title>
      <url>%2F2016%2F11%2F10%2FSQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[原理SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 攻击API在编写过程中没有过滤用户输入的非法字符串，很容易造成sql注入，以mysql-python为例： conn = MySQLdb.connect( host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, # passwd=&apos;&apos;, db=&apos;Test&apos; ) cur = conn.cursor() try: name = &quot;1 or 1 = 1&quot; password = &quot;1 or 1 = 1&quot; sql = &apos;select * from user where name = %s and password = %s&apos;%(name,password) cur.execute(sql) print cur.fetchall() conn.commit() except Exception as e: print e conn.rollback() cur.close() conn.close() result： ((&apos;Tom&apos;, &apos;0000&apos;, &apos;\xe5\xa5\xb3&apos;), (&apos;Alen&apos;, &apos;7875&apos;, &apos;\xe7\x94\xb7&apos;), (&apos;Jack&apos;, &apos;7455&apos;, &apos;\xe7\x94\xb7&apos;)) 很明显使用简单的&quot;1 or 1 = 1&quot;就欺骗了数据库获取了所以user表内容。 防护归纳一下，主要有以下几点： 1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 小结SQL注入的手法相当灵活，在注入的时候会碰到很多意外的情况。能不能根据具体情况进行分析，构造巧妙的SQL语句，从而成功获取想要的数据，是高手与“菜鸟”的根本区别。😊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转载】Ruby China的RubyGems镜像上线]]></title>
      <url>%2F2016%2F11%2F01%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Ruby-China%E7%9A%84RubyGems%E9%95%9C%E5%83%8F%E4%B8%8A%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[公告huacnlee for Ruby China · 发布于 2016年3月09日 · 最后由 huopo125 回复于 2016年5月12日 几年前，由我起头，我们搭建了 ruby.taobao.org 为国内开发者解决 Gem 安装的问题，现在应该国内绝大多数，甚至所有（国内服务器，国内网络）的 Ruby 开发者企业，应该都在用它。 但最近越来越发现之前 ruby.taobao.org 很难同步了，原因有很多，之前的实现方式过于复杂，服务器在国内，同步困难，阿里的网络安全要求维护服务器得是公司员工…. 各种限制导致我们在维护的时候困难重重，尤其是当 @fsword @qhwa 离职以后，根本无法再继续维护了。 为了有一个可持续发展未来，我们考虑由 Ruby China 来负责这个事情，这样可以像现在 Ruby China 社区，RubyConf China 一样，由社区的很多参与者来共同维护。 这件事情我们已经考虑了一年了，之前一直没有找到一个好的方式来解决，以及一些其他因素，比如资金的问题。 这周，我们终于找到了解决方案，也找到了赞助商：腾讯云 整个 gems.ruby-china.org 的架构: 2016-05-18 Updated: Gems 存储放到了 UpYun 上面，通过 UpYun 的 CDN 来解决，同时配合 UpYun 的镜像存储功能，减少回源到国外的次数。 过程: https://ruby-china.org/topics/29978 新的方案的特点 实时的，不再有同步耗时的问题； 全球 400+ CDN 节点（据腾讯官方所说 ~~）为 Gem 下载加速； 更加简单有效的架构，稳定性更高； 背后有两台国外服务器，确保稳定性，确保 CDN 汇源能获取到数据； 原文链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FFmpeg的安装与使用]]></title>
      <url>%2F2016%2F10%2F31%2FFFmpeg%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[简介FFmpeg是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库。“FFmpeg”这个单词中的“FF”指的是“Fast Forward”。有些新手写信给“FFmpeg”的项目负责人，询问FF是不是代表“Fast Free”或者“Fast Fourier”等意思，“FFmpeg”的项目负责人回信说：“Just for the record, the original meaning of “FF” in FFmpeg is “Fast Forward”…”这个项目最初是由Fabrice Bellard发起的，而现在是由Michael Niedermayer在进行维护。许多FFmpeg的开发者同时也是MPlayer项目的成员，FFmpeg在MPlayer项目中是被设计为服务器版本进行开发。2011年3月13日，FFmpeg部分开发人士决定另组Libav，同时制定了一套关于项目继续发展和维护的规则。(From FFmpeg Wiki) 安装brew install ffmpeg 由于license的原因，libvo-aacenc被默认安装，如果想要安装libfaac或者libfdk-aac可以通过以下命令： brew reinstall ffmpeg --with-faac brew reinstall ffmpeg --with-fdk-aac 项目组成libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能 libavcodec：用于各种类型声音/图像编解码 libavutil：包含一些公共的工具函数 libswscale：用于视频场景比例缩放、色彩映射转换 libpostproc：用于后期效果处理 ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等 ffsever：一个 HTTP 多媒体即时广播串流服务器 ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示 命令集ffmpeg 命令集举例 1.获取视频的信息 ffmpeg -i video.avi 2.将图片序列合成视频 ffmpeg -f image2 -i image%d.jpg video.mpg 上面的命令会把当前目录下的图片（名字如：image1.jpg. image2.jpg. 等…）合并成video.mpg 3.将视频分解成图片序列 ffmpeg -i video.mpg image%d.jpg 上面的命令会生成image1.jpg. image2.jpg. …支持的图片格式有：PGM. PPM. PAM. PGMYUV. JPEG. GIF. PNG. TIFF. SGI 4.为视频重新编码以适合在iPod/iPhone上播放 ffmpeg -i source_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final_video.mp4 说明： 源视频：source_video.avi 音频编码：aac 音频位率：128kb/s 视频编码：mpeg4 视频位率：1200kb/s 视频尺寸：320 X 180 生成的视频：final_video.mp4 5.为视频重新编码以适合在PSP上播放 ffmpeg -i source_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final_video.mp4 说明： 源视频：source_video.avi 音频编码：aac 音频位率：32kb/s 视频编码：xvid 视频位率：1200kb/s 视频尺寸：320 X 180 生成的视频：final_video.mp4 6.从视频抽出声音.并存为Mp3 ffmpeg -i source_video.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 sound.mp3 说明： 源视频：source_video.avi 音频位率：192kb/s 输出格式：mp3 生成的声音：sound.mp3 7.将wav文件转成Mp3 ffmpeg -i son_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son_final.mp3 8.将.avi视频转成.mpg ffmpeg -i video_origine.avi video_finale.mpg 9.将.mpg转成.avi ffmpeg -i video_origine.mpg video_finale.avi 10.将.avi转成gif动画（未压缩） ffmpeg -i video_origine.avi gif_anime.gif 11.合成视频和音频 ffmpeg -i son.wav -i video_origine.avi video_finale.mpg 12.将.avi转成.flv ffmpeg -i video_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video_finale.flv 13.将.avi转成dv ffmpeg -i video_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video_finale.dv 或者： ffmpeg -i video_origine.avi -target pal-dv video_finale.dv 14.将.avi压缩成divx ffmpeg -i video_origine.avi -s 320x240 -vcodec msmpeg4v2 video_finale.avi 15.将Ogg Theora压缩成Mpeg dvd ffmpeg -i film_sortie_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film_terminate.mpg 16.将.avi压缩成SVCD mpeg2NTSC格式： ffmpeg -i video_origine.avi -target ntsc-svcd video_finale.mpg PAL格式： ffmpeg -i video_origine.avi -target pal-svcd video_finale.mpg 17.将.avi压缩成VCD mpeg2NTSC格式： ffmpeg -i video_origine.avi -target ntsc-vcd video_finale.mpg PAL格式： ffmpeg -i video_origine.avi -target pal-vcd video_finale.mpg 18.多通道编码 ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2 19.从flv提取mp3 ffmpeg -i source.flv -ab 128k dest.mp3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一个爬虫程序]]></title>
      <url>%2F2016%2F10%2F26%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[前言学习python一段时间了，也了解过爬虫，觉得甚是有趣，于是想自己动手试试，因此诞生了我的第一个爬虫。 环境使用pip安装beautifulsoup4(先翻墙，不然pip会报timeout错误),beautifulsoup省去了繁复的正则,使得开发起来更加友好。 sudo -H pip --default-timeout=100 install beautifulsoup4 实现以下程序主要实现了一个小功能即爬取链家网苏州工业园区100平以下的所有二手房房源，并且生成csv文件（可由excel打开），ps：网站dom会变更代码不具时效性😄。 #!/usr/bin/python # -*- coding: utf-8 -*- import sys import time import requests import urllib2 import codecs reload(sys) sys.setdefaultencoding(&apos;utf8&apos;) from bs4 import BeautifulSoup class houseInfo: def __init__(self,title = &apos;&apos;,address = &apos;&apos;,square =&apos; &apos;,huxing = &apos;&apos;,priceInfo = &apos;&apos;,unitPrice = &apos;&apos;,link = &apos;&apos;): self.title = title self.address = address self.square = square self.huxing = huxing self.priceInfo = priceInfo self.unitPrice = unitPrice self.link = link list = [] def grab(url): # 使用requests或者urllib2都可以 # request = urllib2.Request(url) # response = urllib2.urlopen(request) # plain_text = response.read() source_code = requests.get(url) plain_text = source_code.text soup = BeautifulSoup(plain_text,&quot;html.parser&quot;) list_soup = soup.find(&quot;ul&quot;, class_=&quot;house-lst&quot;).find_all(&apos;li&apos;); for item in list_soup: title = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).a.string address = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-1&quot;).find(&quot;div&quot;, class_=&quot;where&quot;).a.string square = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-1&quot;).find(&quot;div&quot;, class_=&quot;where&quot;).find_all(&apos;span&apos;)[2].string huxing = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-1&quot;).find(&quot;div&quot;, class_=&quot;where&quot;).find_all(&apos;span&apos;)[1].string priceInfo = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-3&quot;).find(&quot;div&quot;, class_=&quot;price&quot;).span.string unitPrice = item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).find(&quot;div&quot;, class_=&quot;col-3&quot;).find(&quot;div&quot;, class_=&quot;price-pre&quot;).string link = &apos;http://su.lianjia.com&apos;+item.find(&quot;div&quot;, class_=&quot;info-panel&quot;).a.get(&apos;href&apos;) info = houseInfo(title,address,square,huxing,priceInfo,unitPrice) single = &apos;%s,%s,%s,%s,%s万,%s,%s\n&apos;%(title,address,square,huxing,priceInfo,unitPrice,link) list.append(single) for i in range(1, 23): page = &quot;http://su.lianjia.com/ershoufang/gongyeyuan/d{0}p1/&quot;.format(str(i)) grab(page) with open(&apos;data.csv&apos;, &apos;w&apos;) as f: for item in list: # BOM_UTF8是为了excel中文不乱码 f.write(codecs.BOM_UTF8.decode(&apos;utf-8&apos;)) f.write(item)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python打包可执行文件]]></title>
      <url>%2F2016%2F10%2F20%2Fpython%E6%89%93%E5%8C%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[PyInstaller 是一个用来将 Python 程序打包成一个独立可执行软件包，支持 Windows、Linux 和 Mac OS X。 InstallationPyInstaller is available on PyPI. You can install it through pip: pip install pyinstaller Tips: 必须翻墙，不然会因为timeout报错,可以加一些参数: sudo -H pip --default-timeout=100 install pyinstaller usage安装完pyinstaller之后就可以开始使用了。 使用pyinstaller生成可执行文件的方法 将依赖文件集中到一个文件夹： pyinstaller -D -w main.py 将所有依赖文件都打包到同一个可执行文件中： pyinstaller -F -w main.py 把main.py替换成你的主入口python文件即可。-w参数代表main.py是一个窗体程序。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[objective-c的工程内使用swift类]]></title>
      <url>%2F2016%2F09%2F19%2Fobjective-c%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%86%85%E4%BD%BF%E7%94%A8swift%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[主要步骤：添加swift桥接,修改项目配置项。 具体步骤如下图： stackoverflow链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git rebase 合并多条commit]]></title>
      <url>%2F2016%2F08%2F18%2Fgit-rebase-%E5%90%88%E5%B9%B6%E5%A4%9A%E6%9D%A1commit%2F</url>
      <content type="text"><![CDATA[目的合并多次commit，保留一次commit信息 步骤查看git log 合并commit2,3,4, 226b17为commit1的hash值 git rebase -i 226b17 :wq :wq commit合并成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从git reset --hard中拯救代码]]></title>
      <url>%2F2016%2F08%2F02%2F%E4%BB%8Egit-reset-hard%E4%B8%AD%E6%8B%AF%E6%95%91%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[场景如果git add .后还未commit输入了git reset --hard,会发现缓存区和本地都没有了这些改动的纪录，因为用了--hard。 挽救由于每次git命令进行操作时git都会对相关文件进行快照,并通过一定形式把信息保存再.git/目录下。 由于此前我使用过git add .命令,因此当文件被放进暂存区时,快照信息对象就已经保存了，而实用git reset --hard之后,这些对象就变成了悬空文件对象(dangling blob)。 我们可以实用git fsck命令显示他们 git fsck：用于验证当前git仓库数据的有效性和一致性，能够显示那些”丢失”的commit、blob(文件)、tree等。 我们可以通过以下命令 git fsck --cache --unreachable $(git for-each-ref --format=&quot;%(objectname)&quot;) 我们得到一大堆blob的hash ID unreachable blob 907b308167f0880fb2a5c0e1614bb0c7620f9dc3 unreachable blob 72663d3adcf67548b9e0f0b2eeef62bce3d53e03 ... 接下来使用git show就能显示这些对象的内容了，例如git show 907b308。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[疲民之术[转载]]]></title>
      <url>%2F2016%2F08%2F01%2F%E7%96%B2%E6%B0%91%E4%B9%8B%E6%9C%AF-%E8%BD%AC%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[原文地址 作者：介子平 新浪博客 任何时代，人民都是被统治的基本因子。人民者，平时出力，战时卖命。崔永元概括曰：“用你当炮灰时，你是无畏的英勇战士。用你创造财富时，你是勤奋的劳动人民。用你当统治基础时，你是光荣的领导阶级。剥夺你的所有财富时，你是乐于奉献的无产者。分享社会财富时，你是体制外的闲杂人员。进行‘义务教育时’，你是非本地户籍暂住人口。疯狂维稳时，你是社会各类不安定因素。”其又谓黎民庶民、子民蒸民、生民草民、兆民平民，又谓苍生百姓、布衣白丁、匹夫群氓、赤子大众。 《商君书》有驭民五术：壹民、弱民、疲民，辱民，贫民。壹民：统一思想，垄断意识形态，实施愚民政策。弱民：民弱国强，国强民弱，治国之道，务在弱民。疲民：为民寻事，使之疲于奔命，不得消停，然后换来统治者的安稳；不停征战，更卒、正卒、戍卒，不停徭役，力役、杂役、军役，使民无暇顾及他事。辱民：使之匍匐于生计，毫无自尊自信，唆之相互检举揭发，终天生活于恐惧氛围。贫民：除却生存必须，剥夺余粮余财，人穷志短，马瘦毛长，只得依赖国家分给，否则便会饿死。五者若不灵，杀之。 制天下者，必先制民，历代统治者奉《商君书》为秘籍宝典，桑弘羊赞之：“功如丘山，名传后世。”王安石赋诗曰：“自古驱民在信诚，一言为重百金轻。今人未可非商鞅，商鞅能令政必行。” 1958年8月21日，毛泽东在北戴河会议上讲话：“民法和刑法那一类法律都不要了。民法刑法那样多条谁记得了？一搞大跃进，就没时间犯法了。”此即疲民之术。在其执政的28年间，大运动套小运动，小运动为大运动，一个运动未结，另一运动已始，大大小小五六十次，唐德刚便说：“毛当国28年，最大的特点就是搞‘运动’，中国老百姓简直可以说没有一时一刻不在胆战心惊的运动中讨生活。”此也疲民之术。人有张弛调剂，农有忙闲间歇，闲时，迎神赛社，赶集听戏，然在学大寨期间，惟剩一忙。耕耘收储自不必说，纵然天寒地冻之时，大搞农田水利建设，平整土地，熟田变生土，美其名曰海绵田，毁林开垦，填湖造地，生态为之破坏，美其名曰人定胜天。期间，送饭地头，送戏田间，只闻周文雍陈铁军刑场上举办过婚礼，却不知有将婚礼办到水库工地上者。捆绑农民于土地，使之不得自由迁徙，此仍疲民之术。 疲民身体的当间，还树立起了若干劳模，号召众人学习之。工业学大庆，农业学大寨，全国学人民解放军。解放军里的先进人物最多，雷锋王杰刘英俊，除去做好事救财产，共同的一点是均毕业于“毛泽东思想大学校”，《毛选》学得好。此外，各行各业各树各的先进，周恩来便欣然道：“天涯处处有芳草，祖国处处有英雄。”有歌唱道：“革命熔炉火最红，毛泽东时代出英雄。”仅大寨的模范人物就有陈永贵、郭凤莲、贾进才、宋立英等。知青中的模范人物更多，著名者有河北的邢燕子、江苏的董家耕、山西的蔡立坚、天津的侯隽等，后来每个省、每个县都树起了自己的模范。黑龙江的金训华名气最大，1969年8月，上海知青金训华在洪水激流中抢救国家财产英勇牺牲，这位知青用以生命为代价抢救的国家财产，原来只是两根电线杆子。之后学金训华成风，表现突出者，可回城可当兵，可推荐工农兵学员，还可巡回作报告，尤其对于那些家庭出生不好者，尚有为救羊羔、扑灭草原野火罹难者，总之，国家利益至上，财产比人命重要，与国家的存在相比，个人简直无足轻重。学先进，赶先进，乃疲民精神之术。精神疲民之要点，在于使民占心，无暇反思自省，无以判断是否。你一旦被别人的观点所左右，实已沦为别人的奴隶。鲁迅说：“做奴隶虽然不幸，但并不可怕，因为知道挣扎，毕竟还有挣脱的希望；若是从奴隶生活中寻出美来，赞叹、陶醉，就是万劫不复的奴才了。”不幸被鲁迅言中，多数人在奴隶生活中找到了乐趣。 基本因子，永远是芸芸莘莘，铺天盖地。以前的教育是“永作革命的螺丝钉”，后来不提“革命”了，就作社会的螺丝钉吧。当你步入社会后便发现，在国家这部巨型机器上，哪有作螺丝钉的机会，你就是块铺路的碎石，终日被人车来回碾压。付出许多，所获极少，工资不高，纳税不低。卫生部部长陈竺曾在“小崔说事”栏目接受崔永元采访时，侃侃而谈医疗改革成果之惠民：“我们免费为一位农村大妈做了白内障手术。当摘下纱布时，她能看见了，她千谢万谢，要感谢这次‘白内障患者复明工程’的项目！靠她自己，她一辈子也做不起手术。”崔永元反问道：“她辛苦一辈子，连个白内障手术都做不起，那她得恨谁呢？” 时下为买房买车，孩子受教育家人看大夫，似乎所有人都在忙忙碌碌，蝇营狗苟，民疲矣。阳光少年一旦计较起柴米油盐，顿已进入中年，诗意泯灭，功利遂滋，浪漫殆尽，世故成习。而“买房保值”“孩子不能输在起跑线上”之类的口号，概念疲民也。这个路线，那个教育，这个主义，那个引导，精神疲民也。无形较之有型，劳心较之劳力，更甚。 在一个设定好的笼子里，任何动作，都是别人期望的表演。提笼之人，就怕你闲着，闲出自省自察、嗜欲爱好来，闲出条分缕析、擘肌剖理来，该是怎样的杵逆不道？圣人早有箴言：“民可使由之，不可使知之。”韩惠王曾派手无寸铁的水利专家郑国，说服秦国兴修水利，意在疲秦而无暇顾及六国。然秦民早已习惯被疲，疲秦不成反利秦。然秦人连年征战，加之筑长城，修阿房，疲民之术终使天下疲民揭竿而起，亡秦者，秦民也。隋炀帝征辽东，挖运河，疲民无奈，篝火狐鸣，亡隋者，隋民也。 对民如此，对君亦然。仇士良檀权揽政20余年，先后杀二王、一妃、四宰相，甚至可当面指斥皇帝，唐文宗哀叹自己受家奴控制，不如亡国之君周赧王、汉献帝。仇士良的事君固位秘诀为：“天子不可令闲暇，暇必观书，见儒臣，则又纳谏，智深虑远，减玩好，省游幸，吾属恩且薄而权轻矣。为诸君计，莫若殖财货，盛鹰马，日以球猎声色蛊其心，极侈靡，使悦不知息，则必斥经术，阇外事，万机在我，恩泽权力欲焉往哉？”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode打包.a静态库step by step]]></title>
      <url>%2F2016%2F07%2F20%2FXcode%E6%89%93%E5%8C%85-a%E9%9D%99%E6%80%81%E5%BA%93step-by-step%2F</url>
      <content type="text"><![CDATA[库介绍库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。iOS中的静态库有 .a 和 .framework两种形式；动态库有.dylib 和 .framework 形式，后来.dylib动态库又被苹果替换成.tbd的形式。 静态库与动态库的区别静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。总结：同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。 创建.a静态库第一步，新建工程。一般使用工程名就使用库的名称，比如我这里用任意一个NSString的Category来创建静态库，我的工程名就取名为Tool，创建的.a静态库就是libTool.a。 第二步，删除系统默认创建的【Tool.h】和【Tool.m】文件，导入需要打包的源文件。 第三步，修改配置 左上角加号－&gt;【New Headers Phase】-&gt; 添加所有需要打包的头文件，如下图： 第四步，修改导出product配置 第五步，修改编译指令集 模拟器：iPhone4s~5 : i386 iPhone5s~6plus : x86_64真机：iPhone3gs~4s : armv7 iPhone5~5c : armv7s iPhone5s~6plus : arm64如果第五步这里，设置为YES，那么编译出来的.a静态库就只包含当前设备的指令集。举个例子：如果我们选择iPhone 5模拟器【Command+B】编译，则编译出来的.a静态库只能用iPhone4s~5模拟器跑程序，用iPhone5s~6plus，则会报找不到x86_64的libTool库。设置为NO，则会把所有指令集的都打包合并。 第六步，编译（快捷键【Command+B】编译时，需要用模拟器和真机各编译一次，这样Products目录下的libTool.a静态库才会变为黑色，右键show in Finder，可以进入Products目录下。 注意：如果步骤四中，不将Build Configuration改为Release,则打包出来的静态库会存于【Debug-iphoneos】和【Debug-iphonesimulator】两个文件夹下。我们一般都使用Release模式，因为程序最终发布之后是Release版的，所以静态库也是在Release模式下使用。 如果想要通用需要将模拟器使用的静态库与真机使用的静态库合并成一个静态库，可以使用终端命令来实现。命令格式：lipo -create 第一个.a文件的绝对路径 第二个.a文件的绝对路径 -output 最终的.a文件路径。本文中使用的命令如下： lipo -create /Users/paul/Library/Developer/Xcode/DerivedData/Tool-fcimdkyxyorzxoafjvdaenioayfh/Build/Products/Release-iphoneos/libTool.a /Users/paul/Library/Developer/Xcode/DerivedData/Tool-fcimdkyxyorzxoafjvdaenioayfh/Build/Products/Release-iphonesimulator/libTool.a -output /Users/paul/Desktop/libTool.a 补充：经过多次实践，第三步的操作省略，依然可以导出可正常使用的包。如果静态库中有category类，则在使用静态库的项目配置中【Other Linker Flags】需要添加参数【-ObjC】或者【-all_load】。 最后，将生成的.a文件以及相应include文件引入即可使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 9 全新Contacts Framework解析]]></title>
      <url>%2F2016%2F07%2F18%2FiOS-9-%E5%85%A8%E6%96%B0Contacts%20Framework%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[引言在以前iOS开发中，涉及联系人相关的编程，代码都非常繁琐，并且框架的设计也不是Objective-C风格的，这使开发者用起来非常的难受。在iOS9中，apple终于解决了这个问题，全新的Contacts Framework将完全替代AddressBookFramework，AddressBookFramework也将成为历史被弃用。 Contact框架的使用 CNContact基本属性 /** * 设置联系人的基本属性 * * @return 返回联系人的对象 */ - (CNMutableContact *)initializeContact{ // 创建联系人对象 CNMutableContact *contact = [[CNMutableContact alloc] init]; // 设置联系人的头像 contact.imageData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;7677360.png&quot;]); // 设置联系人姓名 contact.givenName = @&quot;伟君&quot;; // 设置姓氏 contact.familyName = @&quot;丁&quot;; // 设置联系人邮箱 CNLabeledValue *homeEmail = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:@&quot;12345qq.com&quot;]; CNLabeledValue *workEmail = [CNLabeledValue labeledValueWithLabel:CNLabelWork value:@&quot;32467@sina.cn&quot;]; CNLabeledValue *otherEmail = [CNLabeledValue labeledValueWithLabel:CNLabelOther value:@&quot;lanaj.com&quot;]; contact.emailAddresses = @[homeEmail,workEmail,otherEmail]; // 设置机构名 contact.organizationName = @&quot;互联网&quot;; // 设置部门 contact.departmentName = @&quot;IT&quot;; // 设置工作的名称 contact.jobTitle = @&quot;ios&quot;; // 设置社会的简述 CNSocialProfile *profile = [[CNSocialProfile alloc] initWithUrlString:@&quot;12306.cn&quot; username:@&quot;Paul&quot; userIdentifier:nil service:@&quot;IT行业&quot;]; CNLabeledValue *socialProfile = [CNLabeledValue labeledValueWithLabel:CNSocialProfileServiceGameCenter value:profile]; contact.socialProfiles = @[socialProfile]; // 设置电话号码 CNPhoneNumber *mobileNumber = [[CNPhoneNumber alloc] initWithStringValue:@&quot;18500000000&quot;]; CNLabeledValue *mobilePhone = [[CNLabeledValue alloc] initWithLabel:CNLabelPhoneNumberMobile value:mobileNumber]; contact.phoneNumbers = @[mobilePhone]; // 设置与联系人的关系 CNContactRelation *friend = [[CNContactRelation alloc] initWithName:@&quot;好基友&quot;]; CNLabeledValue *relation = [CNLabeledValue labeledValueWithLabel:CNLabelContactRelationFriend value:friend]; contact.contactRelations = @[relation]; // 设置生日 NSDateComponents *birthday = [[NSDateComponents alloc] init]; birthday.day = 6; birthday.month = 5; birthday.year = 2000; contact.birthday = birthday; return contact; } CNSaveRequest使用 @interface CNSaveRequest : NSObject //添加一个联系人 - (void)addContact:(CNMutableContact *)contact toContainerWithIdentifier:(nullable NSString *)identifier; //更新一个联系人 - (void)updateContact:(CNMutableContact *)contact; //删除一个联系人 - (void)deleteContact:(CNMutableContact *)contact; //添加一组联系人 - (void)addGroup:(CNMutableGroup *)group toContainerWithIdentifier:(nullable NSString *)identifier; //更新一组联系人 - (void)updateGroup:(CNMutableGroup *)group; //删除一组联系人 - (void)deleteGroup:(CNMutableGroup *)group; //向组中添加子组 - (void)addSubgroup:(CNGroup *)subgroup toGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA); //在组中删除子组 - (void)removeSubgroup:(CNGroup *)subgroup fromGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA); //向组中添加成员 - (void)addMember:(CNContact *)contact toGroup:(CNGroup *)group; //向组中移除成员 - (void)removeMember:(CNContact *)contact fromGroup:(CNGroup *)group; @end CNSaveRequest的封装使用 /** * 在group里删除成员 * * @param contact 被删除的联系人 * @param group 在该group里删除联系人 */ - (void)deleteMemberWithContact:(CNContact *)contact toGroup:(CNGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest removeMember:contact fromGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 向group添加成员 * * @param contact 被添加的联系人 * @param group 添加到该group */ - (void)addMemberWithContact:(CNContact *)contact toGroup:(CNGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest addMember:contact toGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 更新group * * @param group 被更新的group */ - (void)updateGroup:(CNMutableGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest updateGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 删除group操作 * * @param group 被删除的group */ - (void)deleteWithGroup:(CNMutableGroup *)group{ CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest deleteGroup:group]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 查询 * * @return 返回数组 */ - (NSArray *)queryGroup{ CNContactStore *store = [[CNContactStore alloc] init]; // 查询所有的group(predicate参数为空时会查询所有的group) NSArray *arr = [store groupsMatchingPredicate:nil error:nil]; return arr; } /** * 添加群组 * * @param name 群组的名称 */ - (void)addGroupWithName:(NSString *)name{ CNMutableGroup *group = [[CNMutableGroup alloc] init]; group.name = name; CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest addGroup:group toContainerWithIdentifier:nil]; // 写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 查询操作 * * @return 返回数组 */ - (NSArray *)queryContactWithName:(NSString *)name{ CNContactStore *store = [[CNContactStore alloc] init]; // 检索条件 NSPredicate *predicate = [CNContact predicateForContactsMatchingName:name]; // 提取数据 （keysToFetch:@[CNContactGivenNameKey]是设置提取联系人的哪些数据） NSArray *contact = [store unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey] error:nil]; return contact; } /** * 更新联系人 * * @param contact 被更新的联系人 */ - (void)updateContact:(CNMutableContact *)contact{ // 创建联系人请求 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest updateContact:contact]; // 重新写入 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 删除联系人 * * @param contact 被删除的联系人 */ - (void)deleteContact:(CNMutableContact *)contact{ // 创建联系人请求 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest deleteContact:contact]; // 写入操作 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } /** * 添加联系人 * * @param contact 联系人 */ - (void)addContact:(CNMutableContact *)contact{ // 创建联系人请求 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; [saveRequest addContact:contact toContainerWithIdentifier:nil]; // 写入联系人 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil]; } 实际工程中的操作使用 - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a ni CNMutableContact *contact = [self initializeContact]; //添加联系人 [self addContact:contact]; //查询 NSArray *arr = [self queryContactWithName:@&quot;伟君&quot;]; //将不可变的CNContact转成CNMutableContact，便可执行以下操作 CNMutableContact *contact = [arr[0] mutableCopy]; //更新 contact.givenName = @&quot;大力&quot;; [self updateContact:contact]; //删除 [self deleteContact:contact]; //添加群组 [self addGroupWithName:@&quot;Yudo&quot;]; //返回所有数组 NSArray *array = [self queryGroup]; NSLog(@&quot;==%@&quot;,array); //删除group操作 CNMutableGroup *group = [array[2] mutableCopy]; [self deleteWithGroup:group]; //更新group CNMutableGroup *group = [array[2] mutableCopy]; group.name = @&quot;Yudo&quot;; [self updateGroup:group]; //向group添加成员 NSArray *results = [self queryContactWithName:@&quot;伟君&quot;]; for (int i=0; i&lt;array.count; i++) { CNGroup *group=array[i]; if ([group.name isEqualToString:@&quot;Yudo&quot;]) { [self addMemberWithContact:results[0] toGroup:group]; } } //在group里删除成员 NSArray *results = [self queryContactWithName:@&quot;baba zhang&quot;]; for (int i=0; i&lt;array.count; i++) { CNGroup *group=array[i]; if ([group.name isEqualToString:@&quot;Yudo&quot;]) { [self deleteMemberWithContact:results[0] toGroup:group]; } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用CAShaperLayer绘制气泡]]></title>
      <url>%2F2016%2F07%2F12%2F%E5%88%A9%E7%94%A8CAShaperLayer%E7%BB%98%E5%88%B6%E6%B0%94%E6%B3%A1%2F</url>
      <content type="text"><![CDATA[实现机制在每一View的layer层中有一个mask属性，他就是专门来设置该View的遮罩效果的。该mask本身也是一个layer层。我们只需要生成一个自定义的layer，然后覆盖在需要遮罩的View上面即可。问题就归于如何生成入上图所示的不规则图片的Layer。CAShapeLayer可以根据几个点的依次连线，产生一个闭合空间的layer。 实现方法 实现一个CAShapeLayer的Category。 + (instancetype)createMaskLayerWithView : (UIView *)view{ CGFloat viewWidth = CGRectGetWidth(view.frame); CGFloat viewHeight = CGRectGetHeight(view.frame); CGFloat rightSpace = 10; CGFloat topSpace = 10; CGFloat radius = 10; CGPoint point1 = CGPointMake(0, radius); CGPoint point2 = CGPointMake(radius, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace-radius, 0); CGPoint point4 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point5 = CGPointMake(viewWidth, topSpace); CGPoint point6 = CGPointMake(viewWidth-rightSpace, topSpace+10); CGPoint point7 = CGPointMake(viewWidth-rightSpace, viewHeight-radius); CGPoint point8 = CGPointMake(viewWidth-rightSpace-radius, viewHeight); CGPoint point9 = CGPointMake(radius, viewHeight); CGPoint point10 = CGPointMake(0, viewHeight-radius); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addArcWithCenter:CGPointMake(radius, radius) radius:radius startAngle:M_PI endAngle:M_PI*1.5 clockwise:YES]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addArcWithCenter:CGPointMake(viewWidth-2*radius, radius) radius:radius startAngle:M_PI*1.5 endAngle:0 clockwise:YES]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path addArcWithCenter:CGPointMake(viewWidth-2*radius, viewHeight-radius) radius:radius startAngle:0 endAngle:M_PI*0.5 clockwise:YES]; [path addLineToPoint:point8]; [path addLineToPoint:point9]; [path addArcWithCenter:CGPointMake(radius, viewHeight-radius) radius:radius startAngle:M_PI*0.5 endAngle:M_PI clockwise:YES]; [path addLineToPoint:point10]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = path.CGPath; return layer; } UIView *view = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 40)]; view.backgroundColor = [UIColor orangeColor]; CAShapeLayer *layer = [CAShapeLayer createMaskLayerWithView:view]; view.layer.mask = layer; [self.view addSubview:view]; 参数说明center：Specifies the center point of the circle (in the current coordinate system) used to define the arc. radius：Specifies the radius of the circle used to define the arc. startAngle： Specifies the starting angle of the arc (measured in radians). endAngle：Specifies the end angle of the arc (measured in raians). clockwise：The direction in which to draw the arc. 实现效果如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS大文件下载遇上nginx反向代理]]></title>
      <url>%2F2016%2F07%2F08%2FiOS%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%81%87%E4%B8%8Anginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[内网部署nginx，直接挂上2g多的zip包，iOS下载正常，将zip包挂到公司服务器，下载到49.1%（差不多1.07G）就中断链接，于是就各种猜测原因。 文件下载代码写的有问题？ NSURLSessionDownload,NSURLConnection,AFN换了个遍都一样,虽然没有找到原因，但是发现NSURLSessionDownload下载时占用内存比NSURLConnection少，机制更优。 服务器的问题？ 安卓可以正常下载，windows浏览器可以正常下载，safari下载到49.1%同样网络中断？what？开始抓包，发现没有异常，只有nginx版本不一样，后来发现公司服务器用了反向代理。 google后尝试写改配置nginx.conf，关闭buffer，proxy_buffering off，可以正常下载了。再尝试开启buffer，然后配置相关参数，也能正常下载，下载的速度和配置的参数有关系，配置参考如下: proxy_cache参数配置文件/usr/local/nginx/conf/proxy.conf proxy_temp_path /home/proxy_temp_dir; proxy_cache_path /home/proxy_cache_dir levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=30g; client_body_buffer_size 512k; proxy_connect_timeout 60; proxy_read_timeout 60; proxy_send_timeout 60; proxy_buffer_size 32k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; proxy_next_upstream error timeout invalid_header http_500 http_503 http_404; proxy_cache cache_one; 至此事情告一段落。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Start NexT]]></title>
      <url>%2F2016%2F05%2F24%2FStart-NexT%2F</url>
      <content type="text"><![CDATA[NexT使用文档 如何将文章分类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F05%2F24%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
